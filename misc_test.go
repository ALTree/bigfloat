package floats

import (
	"math/big"
	"testing"
)

const maxPrec uint = 1100

func TestAgm(t *testing.T) {
	for _, test := range []struct {
		a, b string
		want string
	}{
		// 350 decimal digits are enough to give us up to 1000 binary digits
		{"1", "2", "1.4567910310469068691864323832650819749738639432213055907941723832679264545802509002574737128184484443281894018160367999355762430743401245116912132499522793768970211976726893728266666782707432902072384564600963133367494416649516400826932239086263376738382410254887262645136590660408875885100466728130947439789355129117201754471869564160356411130706061"},
		{"1", "10", "4.2504070949322748617281643183731348667984678641901928596701476622237553127409037845252854607876171790458817135897668652366410690187825866854343005714304399718866701345600268795095037823053677248108795697049522041225723229732458947507697835936406527028150257238518982793084569470658500853106997941082919334694146843915361847332301248942222685517896377"},
		{"1", "1e-10", "0.064344870476013322928970062434704019904166635753907989413179908785955199212299301968662200517382752110335789104786245558044834112001830755379943441746634773634455758483786979961933657914144908818435264659729476727544180928278691077935793490732778592497320876549537697903971642857519005230649567729637142131066175214321022260681805878280126101608196002"},
		{"1", "1e-100", "0.0067810557455754508824285503014605965496451275695705753619094714420564597994083804421955147082056380634831078259873348402107187926550789291677061498878227081682850619454758532505050215820867796354416020295708149698020430968565516662002049984594856727487420876370766556990291526080251268770672512998771780566601499401522099672382411697882276263471808752"},
		{"1", "1e-1000", "0.00068177770584125429009142279977150550091076560383392436961785384435695772011031259701130592984438268095659810817285252509098936940224404459596657840319391959280435431714119410243272333386417334060011989973084583975753976158741002079272227231886642141088474334069986725803539549692318342759020845496425211928634283584732234368542686498241547563547483952"},
		{"1", "1e-10000", "0.000068214710757275370907029672975463631656342241900335263668685743577347857281396823835586085038109483609517960475906178105657685614703876991637762750018215591889863354279063910907271544429318547563463898483729906344206887913742447007929712799629310772793344580058274051956324723991301825951443805444148854018649358756589093191287179237787162400704603317"},

		{"4", "1e-100000", "0.000027287198506226906482523452564848345525025705381114205045778417780503566975134950085622668830412496680491630639935155776221076198899681068681588753857058327482829902116542965635316577851949021792807406088475922399696496311053250151634205205499898200784074446901938994731506920401461267671013333552377860509182061250529681082032836340571209185499300669"},
	} {
		for _, prec := range []uint{24, 53, 64, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000} {
			want := new(big.Float).SetPrec(prec)
			want.Parse(test.want, 10)

			a := new(big.Float).SetPrec(prec + 16) // see sqrt_test.go
			a.Parse(test.a, 10)

			b := new(big.Float).SetPrec(prec + 16) // see sqrt_test.go
			b.Parse(test.b, 10)

			z := agm(a, b)

			wantMaxPrec, _, err := big.ParseFloat(test.want, 0, maxPrec, big.ToNearestEven)
			if err != nil {
				t.Errorf("prec = %d, parse(%s): %v", maxPrec, test.want, err)
			}
			acc := big.Accuracy(want.Cmp(wantMaxPrec))

			z.SetPrec(prec)

			if z.Cmp(want) != 0 || z.Acc() != acc {
				t.Errorf("prec = %d, Agm(%v, %v) = %g (%v); want %g (%v)", prec, test.a, test.b, z, z.Acc(), want, acc)
			}
		}

	}
}

func TestPi(t *testing.T) {
	piStr := "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153644"

	for _, prec := range []uint{24, 53, 64, 100, 200, 300, 400, 500, 600, 700, 800, 900, 1000} {

		want := new(big.Float).SetPrec(prec)
		want.Parse(piStr, 10)

		z := pi(prec)

		wantMaxPrec, _, err := big.ParseFloat(piStr, 0, maxPrec, big.ToNearestEven)
		if err != nil {
			t.Errorf("prec = %d, parse(%s): %v", maxPrec, want, err)
		}
		acc := big.Accuracy(want.Cmp(wantMaxPrec))

		z.SetPrec(prec)

		if z.Cmp(want) != 0 /*|| z.Acc() != acc */ { // not for now
			t.Errorf("pi(%d) = %g (%v); want %g (%v)", prec, z, z.Acc(), want, acc)
		}

	}

}
